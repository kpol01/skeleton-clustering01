---
title: "Skeleton Clustering : A Dimension free Density-Aided Clustering"
author: "| Kaustav Paul\n| Sourav Biswas \n"
institute: "Indian Statistical Institute, Kolkata"
date: "`r Sys.Date()`"
output: 
  beamer_presentation:
    theme: "AnnArbor"
    colortheme: "beaver"
---

```{r setup, include=FALSE, comment=NA}
knitr::opts_chunk$set(echo = FALSE)
```

## Traditional Clustering Methods

-   **k-means clustering:**
    -   Unable to detect non-convex clusters.
    -   The center of a non-convex cluster falls outside the cluster itself and may come close to observations from a different cluster.
    -   In high dimension k-means algorithm may assign all the points to a single cluster.
-   **Density Based Clustering:**
    -   To estimate the underlying PDF and detect clusters based on the PDF.
    -   The rate of convergence for the density estimates is $\mathcal{O}_\mathbb{P}(n^{-\frac{1}{d+4}})$
-   **Hierarchical Clustering:**
    -   Problem with non-convex clusters persists.
    -   If any pair of the points in two different clusters lie very close to each other, the two clusters may get merged in this method. 

## Skeleton Clustering Framework.

**Input :** Observations $X_1,X_2,\ldots,X_N$, final number of clusters $S$.

1.  **Knot construction** : Perform $k-$means clustering with a large number $k$; the centers are the knots.
2.  **Edge construction** : Apply approximate Delaunay triangulation to the knots. Generally we choose $k=\left\lfloor\sqrt{n}\right\rfloor$
3.  **Edge weights construction** : Add weights to each edge using either Voronoi density, Face density or Tube density similarity measure.
4.  **Knots segmentation** : Use linkage criterion to segment knots into $S$ groups based on the edge weights.
5.  **Assignment of labels** : Assign a cluster label to each observation based on which knot group the nearest knot belongs to.



## Knot construction

-   Some knots are constructed to give a concise representation of the data structure.
-   In practice we use $k$-Means to choose $k=\left\lfloor\sqrt{n}\right\rfloor$ knots, where $n$ is the number of samples.
-   Empirically robustness performance with sufficient number of knots.

## Knot Construction

```{r,echo=FALSE, fig.height = 5.5}
#' Generating Yinyang data
#'
#' @param n_m number of points in each of the two moon shapes. Positive integer value or vector with length=2
#' @param n_c number of points in each of the two small circles
#' @param n_r number of points in the outer ring
#' @param sd_c the standard deviation of shifts for points in the two small circles
#' @param sd_r the standard deviation of shifts for points in the outer ring
#' @param d a number indicating the dimension of the generated data. d>2 dimensions are filled with independent Gaussian noises
#' @param sd_high a number indicating the standard deviation for Gaussian noises in the higher dimensions
#' @return A list of generated data points and the true labels
#' \itemize{
#'   \item data - The generated data matrix
#'   \item clus - The vector of true cluster labels for each data point
#' }
#' @export
#' @examples
#' X = Yinyang_data()$data
#' plot(X[,1], X[,2])
Yinyang_data = function(n_m=400,n_c=200,n_r=2000,sd_c=0.1,sd_r=0.1, d=2, sd_high=0.1){
  X_m = clusterSim::shapes.two.moon(n_m)
  
  x1 = cbind(stats::rnorm(n_c, mean= 0.5, sd=sd_c), stats::rnorm(n_c, mean= -1.5, sd=sd_c))
  x2 = cbind(stats::rnorm(n_c, mean= -1, sd=sd_c), stats::rnorm(n_c, mean= 0.5, sd=sd_c))
  
  th = stats::runif(n_r,0,2*pi)
  x  = 2.5*cos(th) - 0.25
  y  = 2.5*sin(th) -0.5
  x3  = cbind(x,y) + matrix(stats::rnorm(2*length(x), sd=sd_r), ncol=2)
  
  X = rbind(X_m$data, x1, x2, x3)
  
  if(d==2){
    X0 = X
  }
  if(d>2){
    n = nrow(X)
    d_add = d-2
    X0 = cbind(X, matrix(stats::rnorm(d_add*(n),  sd = sd_high), nrow = n))
  }
  Y0 = c(X_m$clusters, rep(3,n_c), rep(4,n_c), rep(5,n_r))
  return(list(data = X0, clus = Y0))
}

library(ggplot2)
library(gridExtra)
library(latex2exp)
df=Yinyang_data(n_c = 0,n_r = 0)
gg1=ggplot(data=data.frame("X_1"=df$data[,1],"X_2"=df$data[,2]),aes(x=X_1,y=X_2))+
  geom_point()+labs(x=TeX("$\\X_1$"),y=TeX("$\\X_2$"))
df_km=kmeans(df$data,centers=20)
gg2=ggplot(data=data.frame("X_1"=df$data[,1],"X_2"=df$data[,2]),aes(x=X_1,y=X_2))+
  geom_point(col="darkgrey")+labs(x=TeX("$\\X_1$"),y=TeX("$\\X_2$"))+
  geom_point(data=data.frame("X"=df_km$centers[,1],"Y"=df_km$centers[,2]),aes(x=X,y=Y),col="red",size=2)+
  geom_text(data=data.frame("X"=df_km$centers[,1],"Y"=df_km$centers[,2],"l"=1:20),aes(x=X,y=Y,label=l,hjust=-0.1,vjust=-0.5))
grid.arrange(gg1,gg2,ncol=2)

```
## Edge construction

Let $c_1,c_2,\ldots,c_k$ be the given knots and we use $\mathcal{C}=\left\{c_1,c_2,\ldots,c_k\right\}$ to denote their collection of them.

-   We add an edge between a pair of knots if they are neighbors, with the neighboring condition being that the corresponding Voronoi cells share a common boundary.

-   The Voronoi cell, or Voronoi region, $\mathbb{C}_j$ associated with a knot $c_j$ is the set of all points in $\mathcal{X}$ whose distance to $c_j$ is the smallest compared to other knots. That is, $\mathbb{C}_j=\left\{ \boldsymbol{x}\in\mathcal{X}:d\left(\boldsymbol{x},c_j\right)\leq d\left(\boldsymbol{x},c_\ell\right)\forall \ell\neq j\right\}$ where $d\left(\boldsymbol{x},\boldsymbol{y}\right)$ is the usual Euclidean distance.

-   Such resulting graph is the Delaunay Triangulation of the set of knots $\mathcal{C}$ and we denote is as

-   But in case of high dimensional data, it becomes computationally expensive. Therefore, in practice we approximate the exact Delaunay Triangulation with $\widehat{DT}\left(\mathcal{C}\right)$ by examining the 2-nearest knots of the sample data points.


## Edge Construction

```{r include=FALSE}
df=Yinyang_data(n_c = 0,n_r = 0)


library(skeletonClus)
library(ggplot2)
library(gridExtra)
library(latex2exp)
library(ggvoronoi)


data=data.frame("X_1"=df$data[,1],"X_2"=df$data[,2])
#ggplot(data,aes(x=X_1,y=X_2))+
  #geom_point()+labs(x=TeX("$\\X_1$"),y=TeX("$\\X_2$"))




```
```{r warning=FALSE, out.height="80%", fig.asp = 2, fig.align = 'center'}
skeleton = skeletonCons(data, rep = 1000, k = 20)

ggplot(as.data.frame(skeleton$centers), aes(X_1,X_2)) + stat_voronoi(geom = "path", lty = 2) +geom_point(data = data, col = 'darkgrey', size = 2) + 
  geom_point(data = as.data.frame(skeleton$centers), col = 'red', size = 4)
```


